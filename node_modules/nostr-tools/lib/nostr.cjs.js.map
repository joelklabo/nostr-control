{
  "version": 3,
  "sources": ["../index.ts", "../keys.ts", "../event.ts", "../utils.ts", "../filter.ts", "../fakejson.ts", "../relay.ts", "../pool.ts", "../nip19.ts", "../references.ts", "../nip04.ts", "../nip05.ts", "../nip06.ts", "../nip10.ts", "../nip13.ts", "../nip26.ts", "../nip39.ts", "../nip42.ts", "../nip57.ts"],
  "sourcesContent": ["export * from './keys'\nexport * from './relay'\nexport * from './event'\nexport * from './filter'\nexport * from './pool'\nexport * from './references'\n\nexport * as nip04 from './nip04'\nexport * as nip05 from './nip05'\nexport * as nip06 from './nip06'\nexport * as nip10 from './nip10'\nexport * as nip13 from './nip13'\nexport * as nip19 from './nip19'\nexport * as nip26 from './nip26'\nexport * as nip39 from './nip39'\nexport * as nip42 from './nip42'\nexport * as nip57 from './nip57'\n\nexport * as fj from './fakejson'\nexport * as utils from './utils'\n\n// monkey patch secp256k1\nimport * as secp256k1 from '@noble/secp256k1'\nimport {hmac} from '@noble/hashes/hmac'\nimport {sha256} from '@noble/hashes/sha256'\nsecp256k1.utils.hmacSha256Sync = (key, ...msgs) =>\n  hmac(sha256, key, secp256k1.utils.concatBytes(...msgs))\nsecp256k1.utils.sha256Sync = (...msgs) =>\n  sha256(secp256k1.utils.concatBytes(...msgs))\n", "import * as secp256k1 from '@noble/secp256k1'\n\nexport function generatePrivateKey(): string {\n  return secp256k1.utils.bytesToHex(secp256k1.utils.randomPrivateKey())\n}\n\nexport function getPublicKey(privateKey: string): string {\n  return secp256k1.utils.bytesToHex(secp256k1.schnorr.getPublicKey(privateKey))\n}\n", "import * as secp256k1 from '@noble/secp256k1'\nimport {sha256} from '@noble/hashes/sha256'\n\nimport {utf8Encoder} from './utils'\nimport {getPublicKey} from './keys'\n\n/* eslint-disable no-unused-vars */\nexport enum Kind {\n  Metadata = 0,\n  Text = 1,\n  RecommendRelay = 2,\n  Contacts = 3,\n  EncryptedDirectMessage = 4,\n  EventDeletion = 5,\n  Reaction = 7,\n  BadgeAward = 8,\n  ChannelCreation = 40,\n  ChannelMetadata = 41,\n  ChannelMessage = 42,\n  ChannelHideMessage = 43,\n  ChannelMuteUser = 44,\n  Report = 1984,\n  ZapRequest = 9734,\n  Zap = 9735,\n  RelayList = 10002,\n  ClientAuth = 22242,\n  BadgeDefinition = 30008,\n  ProfileBadge = 30009,\n  Article = 30023\n}\n\nexport type EventTemplate = {\n  kind: Kind\n  tags: string[][]\n  content: string\n  created_at: number\n}\n\nexport type UnsignedEvent = EventTemplate & {\n  pubkey: string\n}\n\nexport type Event = UnsignedEvent & {\n  id: string\n  sig: string\n}\n\nexport function getBlankEvent(): EventTemplate {\n  return {\n    kind: 255,\n    content: '',\n    tags: [],\n    created_at: 0\n  }\n}\n\nexport function finishEvent(t: EventTemplate, privateKey: string): Event {\n  let event = t as Event\n  event.pubkey = getPublicKey(privateKey)\n  event.id = getEventHash(event)\n  event.sig = signEvent(event, privateKey)\n  return event\n}\n\nexport function serializeEvent(evt: UnsignedEvent): string {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\")\n\n  return JSON.stringify([\n    0,\n    evt.pubkey,\n    evt.created_at,\n    evt.kind,\n    evt.tags,\n    evt.content\n  ])\n}\n\nexport function getEventHash(event: UnsignedEvent): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return secp256k1.utils.bytesToHex(eventHash)\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\nexport function verifySignature(event: Event): boolean {\n  return secp256k1.schnorr.verifySync(\n    event.sig,\n    getEventHash(event),\n    event.pubkey\n  )\n}\n\nexport function signEvent(event: UnsignedEvent, key: string): string {\n  return secp256k1.utils.bytesToHex(\n    secp256k1.schnorr.signSync(getEventHash(event), key)\n  )\n}\n", "import {Event} from './event'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if (\n    (p.port === '80' && p.protocol === 'ws:') ||\n    (p.port === '443' && p.protocol === 'wss:')\n  )\n    p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(\n  sortedArray: Event[],\n  event: Event\n) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [\n      ...sortedArray.slice(0, position),\n      event,\n      ...sortedArray.slice(position)\n    ]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(\n  sortedArray: Event[],\n  event: Event\n) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [\n      ...sortedArray.slice(0, position),\n      event,\n      ...sortedArray.slice(position)\n    ]\n  }\n\n  return sortedArray\n}\n", "import {Event} from './event'\n\nexport type Filter = {\n  ids?: string[]\n  kinds?: number[]\n  authors?: string[]\n  since?: number\n  until?: number\n  limit?: number\n  search?: string\n  [key: `#${string}`]: string[]\n}\n\nexport function matchFilter(\n  filter: Filter,\n  event: Event\n): boolean {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    if (!filter.ids.some(prefix => event.id.startsWith(prefix))) {\n      return false\n    }\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    if (!filter.authors.some(prefix => event.pubkey.startsWith(prefix))) {\n      return false\n    }\n  }\n\n  for (let f in filter) {\n    if (f[0] === '#') {\n      let tagName = f.slice(1)\n      let values = filter[`#${tagName}`]\n      if (\n        values &&\n        !event.tags.find(\n          ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1\n        )\n      )\n        return false\n    }\n  }\n\n  if (filter.since && event.created_at < filter.since) return false\n  if (filter.until && event.created_at >= filter.until) return false\n\n  return true\n}\n\nexport function matchFilters(\n  filters: Filter[],\n  event: Event\n): boolean {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event)) return true\n  }\n  return false\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3\n  let idx = json.indexOf(`\"${field}\":`) + len\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1\n  return json.slice(s, s + 64)\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length\n  let idx = json.indexOf(`\"${field}\":`) + len + 3\n  let sliced = json.slice(idx)\n  let end = Math.min(sliced.indexOf(','), sliced.indexOf('}'))\n  return parseInt(sliced.slice(0, end), 10)\n}\n\nexport function getSubscriptionId(json: string): string | null {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`)\n  if (idx === -1) return null\n\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`)\n  if (pstart === -1) return null\n  let start = idx + 7 + 1 + pstart\n\n  let pend = json.slice(start + 1, 80).indexOf(`\"`)\n  if (pend === -1) return null\n  let end = start + 1 + pend\n\n  return json.slice(start + 1, end)\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, 'id')\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, 'pubkey')\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, 'kind')\n}\n", "/* global WebSocket */\n\nimport {Event, verifySignature, validateEvent} from './event'\nimport {Filter, matchFilters} from './filter'\nimport {getHex64, getSubscriptionId} from './fakejson'\n\ntype RelayEvent = {\n  connect: () => void | Promise<void>\n  disconnect: () => void | Promise<void>\n  error: () => void | Promise<void>\n  notice: (msg: string) => void | Promise<void>\n  auth: (challenge: string) => void | Promise<void>\n}\nexport type CountPayload = {\n  count: number\n}\ntype SubEvent = {\n  event: (event: Event) => void | Promise<void>\n  count: (payload: CountPayload) => void | Promise<void>\n  eose: () => void | Promise<void>\n}\nexport type Relay = {\n  url: string\n  status: number\n  connect: () => Promise<void>\n  close: () => void\n  sub: (filters: Filter[], opts?: SubscriptionOptions) => Sub\n  list: (filters: Filter[], opts?: SubscriptionOptions) => Promise<Event[]>\n  get: (filter: Filter, opts?: SubscriptionOptions) => Promise<Event | null>\n  count: (\n    filters: Filter[],\n    opts?: SubscriptionOptions\n  ) => Promise<CountPayload | null>\n  publish: (event: Event) => Pub\n  auth: (event: Event) => Pub\n  off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(\n    event: T,\n    listener: U\n  ) => void\n  on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(\n    event: T,\n    listener: U\n  ) => void\n}\nexport type Pub = {\n  on: (type: 'ok' | 'failed', cb: any) => void\n  off: (type: 'ok' | 'failed', cb: any) => void\n}\nexport type Sub = {\n  sub: (filters: Filter[], opts: SubscriptionOptions) => Sub\n  unsub: () => void\n  on: <T extends keyof SubEvent, U extends SubEvent[T]>(\n    event: T,\n    listener: U\n  ) => void\n  off: <T extends keyof SubEvent, U extends SubEvent[T]>(\n    event: T,\n    listener: U\n  ) => void\n}\n\nexport type SubscriptionOptions = {\n  id?: string\n  verb?: 'REQ' | 'COUNT'\n  skipVerification?: boolean\n  alreadyHaveEvent?: null | ((id: string, relay: string) => boolean)\n}\n\nconst newListeners = (): {[TK in keyof RelayEvent]: RelayEvent[TK][]} => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: []\n})\n\nexport function relayInit(\n  url: string,\n  options: {\n    getTimeout?: number\n    listTimeout?: number\n    countTimeout?: number\n  } = {}\n): Relay {\n  let {listTimeout = 3000, getTimeout = 3000, countTimeout = 3000} = options\n\n  var ws: WebSocket\n  var openSubs: {[id: string]: {filters: Filter[]} & SubscriptionOptions} = {}\n  var listeners = newListeners()\n  var subListeners: {\n    [subid: string]: {[TK in keyof SubEvent]: SubEvent[TK][]}\n  } = {}\n  var pubListeners: {\n    [eventid: string]: {\n      ok: Array<() => void>\n      seen: Array<() => void>\n      failed: Array<(reason: string) => void>\n    }\n  } = {}\n\n  var connectionPromise: Promise<void> | undefined\n  async function connectRelay(): Promise<void> {\n    if (connectionPromise) return connectionPromise\n    connectionPromise = new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url)\n      } catch (err) {\n        reject(err)\n      }\n\n      ws.onopen = () => {\n        listeners.connect.forEach(cb => cb())\n        resolve()\n      }\n      ws.onerror = () => {\n        connectionPromise = undefined\n        listeners.error.forEach(cb => cb())\n        reject()\n      }\n      ws.onclose = async () => {\n        connectionPromise = undefined\n        listeners.disconnect.forEach(cb => cb())\n      }\n\n      let incomingMessageQueue: string[] = []\n      let handleNextInterval: any\n\n      ws.onmessage = e => {\n        incomingMessageQueue.push(e.data)\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0)\n        }\n      }\n\n      function handleNext() {\n        if (incomingMessageQueue.length === 0) {\n          clearInterval(handleNextInterval)\n          handleNextInterval = null\n          return\n        }\n\n        var json = incomingMessageQueue.shift()\n        if (!json) return\n\n        let subid = getSubscriptionId(json)\n        if (subid) {\n          let so = openSubs[subid]\n          if (\n            so &&\n            so.alreadyHaveEvent &&\n            so.alreadyHaveEvent(getHex64(json, 'id'), url)\n          ) {\n            return\n          }\n        }\n\n        try {\n          let data = JSON.parse(json)\n\n          // we won't do any checks against the data since all failures (i.e. invalid messages from relays)\n          // will naturally be caught by the encompassing try..catch block\n\n          switch (data[0]) {\n            case 'EVENT': {\n              let id = data[1]\n              let event = data[2]\n              if (\n                validateEvent(event) &&\n                openSubs[id] &&\n                (openSubs[id].skipVerification || verifySignature(event)) &&\n                matchFilters(openSubs[id].filters, event)\n              ) {\n                openSubs[id]\n                ;(subListeners[id]?.event || []).forEach(cb => cb(event))\n              }\n              return\n            }\n            case 'COUNT':\n              let id = data[1]\n              let payload = data[2]\n              if (openSubs[id]) {\n                ;(subListeners[id]?.count || []).forEach(cb => cb(payload))\n              }\n              return\n            case 'EOSE': {\n              let id = data[1]\n              if (id in subListeners) {\n                subListeners[id].eose.forEach(cb => cb())\n                subListeners[id].eose = [] // 'eose' only happens once per sub, so stop listeners here\n              }\n              return\n            }\n            case 'OK': {\n              let id: string = data[1]\n              let ok: boolean = data[2]\n              let reason: string = data[3] || ''\n              if (id in pubListeners) {\n                if (ok) pubListeners[id].ok.forEach(cb => cb())\n                else pubListeners[id].failed.forEach(cb => cb(reason))\n                pubListeners[id].ok = [] // 'ok' only happens once per pub, so stop listeners here\n                pubListeners[id].failed = []\n              }\n              return\n            }\n            case 'NOTICE':\n              let notice = data[1]\n              listeners.notice.forEach(cb => cb(notice))\n              return\n            case 'AUTH': {\n              let challenge = data[1]\n              listeners.auth?.forEach(cb => cb(challenge))\n              return\n            }\n          }\n        } catch (err) {\n          return\n        }\n      }\n    })\n\n    return connectionPromise\n  }\n\n  function connected() {\n    return ws?.readyState === 1\n  }\n\n  async function connect(): Promise<void> {\n    if (connected()) return // ws already open\n    await connectRelay()\n  }\n\n  async function trySend(params: [string, ...any]) {\n    let msg = JSON.stringify(params)\n    if (!connected()) {\n      await new Promise(resolve => setTimeout(resolve, 1000))\n      if (!connected()) {\n        return\n      }\n    }\n    try {\n      ws.send(msg)\n    } catch (err) {\n      console.log(err)\n    }\n  }\n\n  const sub = (\n    filters: Filter[],\n    {\n      verb = 'REQ',\n      skipVerification = false,\n      alreadyHaveEvent = null,\n      id = Math.random().toString().slice(2)\n    }: SubscriptionOptions = {}\n  ): Sub => {\n    let subid = id\n\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent\n    }\n    trySend([verb, subid, ...filters])\n\n    return {\n      sub: (newFilters, newOpts = {}) =>\n        sub(newFilters || filters, {\n          skipVerification: newOpts.skipVerification || skipVerification,\n          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n          id: subid\n        }),\n      unsub: () => {\n        delete openSubs[subid]\n        delete subListeners[subid]\n        trySend(['CLOSE', subid])\n      },\n      on: <T extends keyof SubEvent, U extends SubEvent[T]>(\n        type: T,\n        cb: U\n      ): void => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          count: [],\n          eose: []\n        }\n        subListeners[subid][type].push(cb)\n      },\n      off: <T extends keyof SubEvent, U extends SubEvent[T]>(\n        type: T,\n        cb: U\n      ): void => {\n        let listeners = subListeners[subid]\n        let idx = listeners[type].indexOf(cb)\n        if (idx >= 0) listeners[type].splice(idx, 1)\n      }\n    }\n  }\n\n  function _publishEvent(event: Event, type: string) {\n    if (!event.id) throw new Error(`event ${event} has no id`)\n    let id = event.id\n\n    trySend([type, event])\n\n    return {\n      on: (type: 'ok' | 'failed', cb: any) => {\n        pubListeners[id] = pubListeners[id] || {\n          ok: [],\n          failed: []\n        }\n        pubListeners[id][type].push(cb)\n      },\n      off: (type: 'ok' | 'failed', cb: any) => {\n        let listeners = pubListeners[id]\n        if (!listeners) return\n        let idx = listeners[type].indexOf(cb)\n        if (idx >= 0) listeners[type].splice(idx, 1)\n      }\n    }\n  }\n\n  return {\n    url,\n    sub,\n    on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(\n      type: T,\n      cb: U\n    ): void => {\n      listeners[type].push(cb)\n      if (type === 'connect' && ws?.readyState === 1) {\n        // i would love to know why we need this\n        ;(cb as () => void)()\n      }\n    },\n    off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(\n      type: T,\n      cb: U\n    ): void => {\n      let index = listeners[type].indexOf(cb)\n      if (index !== -1) listeners[type].splice(index, 1)\n    },\n    list: (filters: Filter[], opts?: SubscriptionOptions): Promise<Event[]> =>\n      new Promise(resolve => {\n        let s = sub(filters, opts)\n        let events: Event[] = []\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(events)\n        }, listTimeout)\n        s.on('eose', () => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(events)\n        })\n        s.on('event', (event: Event) => {\n          events.push(event)\n        })\n      }),\n    get: (filter: Filter, opts?: SubscriptionOptions): Promise<Event | null> =>\n      new Promise(resolve => {\n        let s = sub([filter], opts)\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, getTimeout)\n        s.on('event', (event: Event) => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    count: (filters: Filter[]): Promise<CountPayload | null> =>\n      new Promise(resolve => {\n        let s = sub(filters, {...sub, verb: 'COUNT'})\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, countTimeout)\n        s.on('count', (event: CountPayload) => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    publish(event): Pub {\n      return _publishEvent(event, 'EVENT')\n    },\n    auth(event): Pub {\n      return _publishEvent(event, 'AUTH')\n    },\n    connect,\n    close(): void {\n      listeners = newListeners()\n      subListeners = {}\n      pubListeners = {}\n      if (ws.readyState === WebSocket.OPEN) {\n        ws?.close()\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3\n    }\n  }\n}\n", "import {Relay, relayInit} from './relay'\nimport {normalizeURL} from './utils'\nimport {Filter} from './filter'\nimport {Event} from './event'\nimport {SubscriptionOptions, Sub, Pub, CountPayload} from './relay'\n\nexport class SimplePool {\n  private _conn: {[url: string]: Relay}\n  private _seenOn: {[id: string]: Set<string>} = {} // a map of all events we've seen in each relay\n\n  private eoseSubTimeout: number\n  private getTimeout: number\n\n  constructor(options: {eoseSubTimeout?: number; getTimeout?: number} = {}) {\n    this._conn = {}\n    this.eoseSubTimeout = options.eoseSubTimeout || 3400\n    this.getTimeout = options.getTimeout || 3400\n  }\n\n  close(relays: string[]): void {\n    relays.forEach(url => {\n      let relay = this._conn[normalizeURL(url)]\n      if (relay) relay.close()\n    })\n  }\n\n  async ensureRelay(url: string): Promise<Relay> {\n    const nm = normalizeURL(url)\n\n    if (!this._conn[nm]) {\n      this._conn[nm] = relayInit(nm, {\n        getTimeout: this.getTimeout * 0.9,\n        listTimeout: this.getTimeout * 0.9\n      })\n    }\n\n    const relay = this._conn[nm]\n    await relay.connect()\n    return relay\n  }\n\n  sub(relays: string[], filters: Filter[], opts?: SubscriptionOptions): Sub {\n    let _knownIds: Set<string> = new Set()\n    let modifiedOpts = {...(opts || {})}\n    modifiedOpts.alreadyHaveEvent = (id, url) => {\n      if (opts?.alreadyHaveEvent?.(id, url)) {\n        return true\n      }\n      let set = this._seenOn[id] || new Set()\n      set.add(url)\n      this._seenOn[id] = set\n      return _knownIds.has(id)\n    }\n\n    let subs: Sub[] = []\n    let eventListeners: Set<any> = new Set()\n    let eoseListeners: Set<() => void> = new Set()\n    let eosesMissing = relays.length\n\n    let eoseSent = false\n    let eoseTimeout = setTimeout(() => {\n      eoseSent = true\n      for (let cb of eoseListeners.values()) cb()\n    }, this.eoseSubTimeout)\n\n    relays.forEach(async relay => {\n      let r\n      try {\n        r = await this.ensureRelay(relay)\n      } catch (err) {\n        handleEose()\n        return\n      }\n      if (!r) return\n      let s = r.sub(filters, modifiedOpts)\n      s.on('event', (event: Event) => {\n        _knownIds.add(event.id as string)\n        for (let cb of eventListeners.values()) cb(event)\n      })\n      s.on('eose', () => {\n        if (eoseSent) return\n        handleEose()\n      })\n      subs.push(s)\n\n      function handleEose() {\n        eosesMissing--\n        if (eosesMissing === 0) {\n          clearTimeout(eoseTimeout)\n          for (let cb of eoseListeners.values()) cb()\n        }\n      }\n    })\n\n    let greaterSub: Sub = {\n      sub(filters, opts) {\n        subs.forEach(sub => sub.sub(filters, opts))\n        return greaterSub\n      },\n      unsub() {\n        subs.forEach(sub => sub.unsub())\n      },\n      on(type, cb) {\n        if (type === 'event') {\n          eventListeners.add(cb)\n        } else if (type === 'eose') {\n          eoseListeners.add(cb as () => void | Promise<void>)\n        }\n      },\n      off(type, cb) {\n        if (type === 'event') {\n          eventListeners.delete(cb)\n        } else if (type === 'eose')\n          eoseListeners.delete(cb as () => void | Promise<void>)\n      }\n    }\n\n    return greaterSub\n  }\n\n  get(\n    relays: string[],\n    filter: Filter,\n    opts?: SubscriptionOptions\n  ): Promise<Event | null> {\n    return new Promise(resolve => {\n      let sub = this.sub(relays, [filter], opts)\n      let timeout = setTimeout(() => {\n        sub.unsub()\n        resolve(null)\n      }, this.getTimeout)\n      sub.on('event', (event: Event) => {\n        resolve(event)\n        clearTimeout(timeout)\n        sub.unsub()\n      })\n    })\n  }\n\n  list(\n    relays: string[],\n    filters: Filter[],\n    opts?: SubscriptionOptions\n  ): Promise<Event[]> {\n    return new Promise(resolve => {\n      let events: Event[] = []\n      let sub = this.sub(relays, filters, opts)\n\n      sub.on('event', (event: Event) => {\n        events.push(event)\n      })\n\n      // we can rely on an eose being emitted here because pool.sub() will fake one\n      sub.on('eose', () => {\n        sub.unsub()\n        resolve(events)\n      })\n    })\n  }\n\n  publish(relays: string[], event: Event): Pub {\n    const pubPromises: Promise<Pub>[] = relays.map(async relay => {\n      let r\n      try {\n        r = await this.ensureRelay(relay)\n        return r.publish(event)\n      } catch (_) {\n        return {on() {}, off() {}}\n      }\n    })\n\n    const callbackMap = new Map()\n\n    return {\n      on(type, cb) {\n        relays.forEach(async (relay, i) => {\n          let pub = await pubPromises[i]\n          let callback = () => cb(relay)\n          callbackMap.set(cb, callback)\n          pub.on(type, callback)\n        })\n      },\n\n      off(type, cb) {\n        relays.forEach(async (_, i) => {\n          let callback = callbackMap.get(cb)\n          if (callback) {\n            let pub = await pubPromises[i]\n            pub.off(type, callback)\n          }\n        })\n      }\n    }\n  }\n\n  seenOn(id: string): string[] {\n    return Array.from(this._seenOn[id]?.values?.() || [])\n  }\n}\n", "import * as secp256k1 from '@noble/secp256k1'\nimport {bech32} from '@scure/base'\n\nimport {utf8Decoder, utf8Encoder} from './utils'\n\nconst Bech32MaxSize = 5000\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\nexport type DecodeResult =\n  | {type: 'nprofile'; data: ProfilePointer}\n  | {type: 'nrelay'; data: string}\n  | {type: 'nevent'; data: EventPointer}\n  | {type: 'naddr'; data: AddressPointer}\n  | {type: 'nsec'; data: string}\n  | {type: 'npub'; data: string}\n  | {type: 'note'; data: string}\n\nexport function decode(nip19: string): DecodeResult {\n  let {prefix, words} = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: secp256k1.utils.bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : []\n        }\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error('TLV 2 should be 32 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: secp256k1.utils.bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0]\n            ? secp256k1.utils.bytesToHex(tlv[2][0])\n            : undefined\n        }\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: secp256k1.utils.bytesToHex(tlv[2][0]),\n          kind: parseInt(secp256k1.utils.bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : []\n        }\n      }\n    }\n\n    case 'nrelay': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nrelay')\n\n      return {\n        type: 'nrelay',\n        data: utf8Decoder.decode(tlv[0][0])\n      }\n    }\n\n    case 'nsec':\n    case 'npub':\n    case 'note':\n      return {type: prefix, data: secp256k1.utils.bytesToHex(data)}\n\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = {[t: number]: Uint8Array[]}\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) continue\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(hex: string): string {\n  return encodeBytes('nsec', hex)\n}\n\nexport function npubEncode(hex: string): string {\n  return encodeBytes('npub', hex)\n}\n\nexport function noteEncode(hex: string): string {\n  return encodeBytes('note', hex)\n}\n\nfunction encodeBytes(prefix: string, hex: string): string {\n  let data = secp256k1.utils.hexToBytes(hex)\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): string {\n  let data = encodeTLV({\n    0: [secp256k1.utils.hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url))\n  })\n  let words = bech32.toWords(data)\n  return bech32.encode('nprofile', words, Bech32MaxSize)\n}\n\nexport function neventEncode(event: EventPointer): string {\n  let data = encodeTLV({\n    0: [secp256k1.utils.hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [secp256k1.utils.hexToBytes(event.author)] : []\n  })\n  let words = bech32.toWords(data)\n  return bech32.encode('nevent', words, Bech32MaxSize)\n}\n\nexport function naddrEncode(addr: AddressPointer): string {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [secp256k1.utils.hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  })\n  let words = bech32.toWords(data)\n  return bech32.encode('naddr', words, Bech32MaxSize)\n}\n\nexport function nrelayEncode(url: string): string {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)]\n  })\n  let words = bech32.toWords(data)\n  return bech32.encode('nrelay', words, Bech32MaxSize)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach(v => {\n      let entry = new Uint8Array(v.length + 2)\n      entry.set([parseInt(t)], 0)\n      entry.set([v.length], 1)\n      entry.set(v, 2)\n      entries.push(entry)\n    })\n  })\n\n  return secp256k1.utils.concatBytes(...entries)\n}\n", "import {Event} from './event'\nimport {decode, AddressPointer, ProfilePointer, EventPointer} from './nip19'\n\ntype Reference = {\n  text: string\n  profile?: ProfilePointer\n  event?: EventPointer\n  address?: AddressPointer\n}\n\nconst mentionRegex =\n  /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g\n\nexport function parseReferences(evt: Event): Reference[] {\n  let references: Reference[] = []\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      // it's a NIP-27 mention\n      try {\n        let {type, data} = decode(ref[1])\n        switch (type) {\n          case 'npub': {\n            references.push({\n              text: ref[0],\n              profile: {pubkey: data as string, relays: []}\n            })\n            break\n          }\n          case 'nprofile': {\n            references.push({\n              text: ref[0],\n              profile: data as ProfilePointer\n            })\n            break\n          }\n          case 'note': {\n            references.push({\n              text: ref[0],\n              event: {id: data as string, relays: []}\n            })\n            break\n          }\n          case 'nevent': {\n            references.push({\n              text: ref[0],\n              event: data as EventPointer\n            })\n            break\n          }\n          case 'naddr': {\n            references.push({\n              text: ref[0],\n              address: data as AddressPointer\n            })\n            break\n          }\n        }\n      } catch (err) {\n        /***/\n      }\n    } else if (ref[3]) {\n      // it's a NIP-10 mention\n      let idx = parseInt(ref[3], 10)\n      let tag = evt.tags[idx]\n      if (!tag) continue\n\n      switch (tag[0]) {\n        case 'p': {\n          references.push({\n            text: ref[0],\n            profile: {pubkey: tag[1], relays: tag[2] ? [tag[2]] : []}\n          })\n          break\n        }\n        case 'e': {\n          references.push({\n            text: ref[0],\n            event: {id: tag[1], relays: tag[2] ? [tag[2]] : []}\n          })\n          break\n        }\n        case 'a': {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(':')\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            })\n          } catch (err) {\n            /***/\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return references\n}\n", "import {randomBytes} from '@noble/hashes/utils'\nimport * as secp256k1 from '@noble/secp256k1'\nimport {base64} from '@scure/base'\n\nimport {utf8Decoder, utf8Encoder} from './utils'\n\nexport async function encrypt(\n  privkey: string,\n  pubkey: string,\n  text: string\n): Promise<string> {\n  const key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  const normalizedKey = getNormalizedX(key)\n\n  let iv = Uint8Array.from(randomBytes(16))\n  let plaintext = utf8Encoder.encode(text)\n  let cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    normalizedKey,\n    {name: 'AES-CBC'},\n    false,\n    ['encrypt']\n  )\n  let ciphertext = await crypto.subtle.encrypt(\n    {name: 'AES-CBC', iv},\n    cryptoKey,\n    plaintext\n  )\n  let ctb64 = base64.encode(new Uint8Array(ciphertext))\n  let ivb64 = base64.encode(new Uint8Array(iv.buffer))\n\n  return `${ctb64}?iv=${ivb64}`\n}\n\nexport async function decrypt(\n  privkey: string,\n  pubkey: string,\n  data: string\n): Promise<string> {\n  let [ctb64, ivb64] = data.split('?iv=')\n  let key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  let normalizedKey = getNormalizedX(key)\n\n  let cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    normalizedKey,\n    {name: 'AES-CBC'},\n    false,\n    ['decrypt']\n  )\n  let ciphertext = base64.decode(ctb64)\n  let iv = base64.decode(ivb64)\n\n  let plaintext = await crypto.subtle.decrypt(\n    {name: 'AES-CBC', iv},\n    cryptoKey,\n    ciphertext\n  )\n\n  let text = utf8Decoder.decode(plaintext)\n  return text\n}\n\nfunction getNormalizedX(key: Uint8Array): Uint8Array {\n  return key.slice(1, 33)\n}\n", "import {ProfilePointer} from './nip19'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function searchDomain(\n  domain: string,\n  query = ''\n): Promise<{[name: string]: string}> {\n  try {\n    let res = await (\n      await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)\n    ).json()\n\n    return res.names\n  } catch (_) {\n    return {}\n  }\n}\n\nexport async function queryProfile(\n  fullname: string\n): Promise<ProfilePointer | null> {\n  let [name, domain] = fullname.split('@')\n\n  if (!domain) {\n    // if there is no @, it is because it is just a domain, so assume the name is \"_\"\n    domain = name\n    name = '_'\n  }\n\n  if (!name.match(/^[A-Za-z0-9-_.]+$/)) return null\n  if (!domain.includes('.')) return null\n\n  let res\n  try {\n    res = await (\n      await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)\n    ).json()\n  } catch (err) {\n    return null\n  }\n\n  if (!res?.names?.[name]) return null\n\n  let pubkey = res.names[name] as string\n  let relays = (res.relays?.[pubkey] || []) as string[] // nip35\n\n  return {\n    pubkey,\n    relays\n  }\n}\n", "import * as secp256k1 from '@noble/secp256k1'\nimport {wordlist} from '@scure/bip39/wordlists/english.js'\nimport {\n  generateMnemonic,\n  mnemonicToSeedSync,\n  validateMnemonic\n} from '@scure/bip39'\nimport {HDKey} from '@scure/bip32'\n\nexport function privateKeyFromSeedWords(\n  mnemonic: string,\n  passphrase?: string\n): string {\n  let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey\n  if (!privateKey) throw new Error('could not derive private key')\n  return secp256k1.utils.bytesToHex(privateKey)\n}\n\nexport function generateSeedWords(): string {\n  return generateMnemonic(wordlist)\n}\n\nexport function validateWords(words: string): boolean {\n  return validateMnemonic(words, wordlist)\n}\n", "import type {Event} from './event'\nimport type {EventPointer, ProfilePointer} from './nip19'\n\nexport type NIP10Result = {\n  /**\n   * Pointer to the root of the thread.\n   */\n  root: EventPointer | undefined\n\n  /**\n   * Pointer to a \"parent\" event that parsed event replies to (responded to).\n   */\n  reply: EventPointer | undefined\n\n  /**\n   * Pointers to events which may or may not be in the reply chain.\n   */\n  mentions: EventPointer[]\n\n  /**\n   * List of pubkeys that are involved in the thread in no particular order.\n   */\n  profiles: ProfilePointer[]\n}\n\nexport function parse(event: Pick<Event, 'tags'>): NIP10Result {\n  const result: NIP10Result = {\n    reply: undefined,\n    root: undefined,\n    mentions: [],\n    profiles: []\n  }\n\n  const eTags: string[][] = []\n\n  for (const tag of event.tags) {\n    if (tag[0] === 'e' && tag[1]) {\n      eTags.push(tag)\n    }\n\n    if (tag[0] === 'p' && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      })\n    }\n  }\n\n  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {\n    const eTag = eTags[eTagIndex]\n\n    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag as [\n      string,\n      string,\n      undefined | string,\n      undefined | string\n    ]\n\n    const eventPointer: EventPointer = {\n      id: eTagEventId,\n      relays: eTagRelayUrl ? [eTagRelayUrl] : []\n    }\n\n    const isFirstETag = eTagIndex === 0\n    const isLastETag = eTagIndex === eTags.length - 1\n\n    if (eTagMarker === 'root') {\n      result.root = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'reply') {\n      result.reply = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'mention') {\n      result.mentions.push(eventPointer)\n      continue\n    }\n\n    if (isFirstETag) {\n      result.root = eventPointer\n      continue\n    }\n\n    if (isLastETag) {\n      result.reply = eventPointer\n      continue\n    }\n\n    result.mentions.push(eventPointer)\n  }\n\n  return result\n}\n", "import * as secp256k1 from '@noble/secp256k1'\n\n/** Get POW difficulty from a Nostr hex ID. */\nexport function getPow(id: string): number {\n  return getLeadingZeroBits(secp256k1.utils.hexToBytes(id))\n}\n\n/**\n * Get number of leading 0 bits. Adapted from nostream.\n * https://github.com/Cameri/nostream/blob/fb6948fd83ca87ce552f39f9b5eb780ea07e272e/src/utils/proof-of-work.ts\n */\nfunction getLeadingZeroBits(hash: Uint8Array): number {\n  let total: number, i: number, bits: number\n\n  for (i = 0, total = 0; i < hash.length; i++) {\n    bits = msb(hash[i])\n    total += bits\n    if (bits !== 8) {\n      break\n    }\n  }\n  return total\n}\n\n/**\n * Adapted from nostream.\n * https://github.com/Cameri/nostream/blob/fb6948fd83ca87ce552f39f9b5eb780ea07e272e/src/utils/proof-of-work.ts\n */\nfunction msb(b: number) {\n  let n = 0\n\n  if (b === 0) {\n    return 8\n  }\n\n  // eslint-disable-next-line no-cond-assign\n  while (b >>= 1) {\n    n++\n  }\n\n  return 7 - n\n}\n", "import * as secp256k1 from '@noble/secp256k1'\nimport {sha256} from '@noble/hashes/sha256'\n\nimport {Event} from './event'\nimport {utf8Encoder} from './utils'\nimport {getPublicKey} from './keys'\n\nexport type Parameters = {\n  pubkey: string // the key to whom the delegation will be given\n  kind: number | undefined\n  until: number | undefined // delegation will only be valid until this date\n  since: number | undefined // delegation will be valid from this date on\n}\n\nexport type Delegation = {\n  from: string // the pubkey who signed the delegation\n  to: string // the pubkey that is allowed to use the delegation\n  cond: string // the string of conditions as they should be included in the event tag\n  sig: string\n}\n\nexport function createDelegation(\n  privateKey: string,\n  parameters: Parameters\n): Delegation {\n  let conditions = []\n  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`)\n  if (parameters.until) conditions.push(`created_at<${parameters.until}`)\n  if (parameters.since) conditions.push(`created_at>${parameters.since}`)\n  let cond = conditions.join('&')\n\n  if (cond === '')\n    throw new Error('refusing to create a delegation without any conditions')\n\n  let sighash = sha256(\n    utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`)\n  )\n\n  let sig = secp256k1.utils.bytesToHex(\n    secp256k1.schnorr.signSync(sighash, privateKey)\n  )\n\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig\n  }\n}\n\nexport function getDelegator(event: Event): string | null {\n  // find delegation tag\n  let tag = event.tags.find(tag => tag[0] === 'delegation' && tag.length >= 4)\n  if (!tag) return null\n\n  let pubkey = tag[1]\n  let cond = tag[2]\n  let sig = tag[3]\n\n  // check conditions\n  let conditions = cond.split('&')\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/)\n\n    // the supported conditions are just 'kind' and 'created_at' for now\n    if (key === 'kind' && operator === '=' && event.kind === parseInt(value))\n      continue\n    else if (\n      key === 'created_at' &&\n      operator === '<' &&\n      event.created_at < parseInt(value)\n    )\n      continue\n    else if (\n      key === 'created_at' &&\n      operator === '>' &&\n      event.created_at > parseInt(value)\n    )\n      continue\n    else return null // invalid condition\n  }\n\n  // check signature\n  let sighash = sha256(\n    utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)\n  )\n  if (!secp256k1.schnorr.verifySync(sig, sighash, pubkey)) return null\n\n  return pubkey\n}\n", "var _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function validateGithub(\n  pubkey: string,\n  username: string,\n  proof: string\n): Promise<boolean> {\n  try {\n    let res = await (\n      await _fetch(`https://gist.github.com/${username}/${proof}/raw`)\n    ).text()\n    return (\n      res ===\n      `Verifying that I control the following Nostr public key: ${pubkey}`\n    )\n  } catch (_) {\n    return false\n  }\n}\n", "import {EventTemplate, Event, Kind} from './event'\nimport {Relay} from './relay'\n\n/**\n * Authenticate via NIP-42 flow.\n *\n * @example\n * const sign = window.nostr.signEvent\n * relay.on('auth', challenge =>\n *   authenticate({ relay, sign, challenge })\n * )\n */\nexport const authenticate = async ({\n  challenge,\n  relay,\n  sign\n}: {\n  challenge: string\n  relay: Relay\n  sign: (e: EventTemplate) => Promise<Event>\n}): Promise<void> => {\n  const e: EventTemplate = {\n    kind: Kind.ClientAuth,\n    created_at: Math.floor(Date.now() / 1000),\n    tags: [\n      ['relay', relay.url],\n      ['challenge', challenge]\n    ],\n    content: ''\n  }\n  const pub = relay.auth(await sign(e))\n  return new Promise((resolve, reject) => {\n    pub.on('ok', function ok() {\n      pub.off('ok', ok)\n      resolve()\n    })\n    pub.on('failed', function fail(reason: string) {\n      pub.off('failed', fail)\n      reject(reason)\n    })\n  })\n}\n", "import {bech32} from '@scure/base'\n\nimport {Event, EventTemplate, validateEvent, verifySignature} from './event'\nimport {utf8Decoder} from './utils'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function getZapEndpoint(metadata: Event): Promise<null | string> {\n  try {\n    let lnurl: string = ''\n    let {lud06, lud16} = JSON.parse(metadata.content)\n    if (lud06) {\n      let {words} = bech32.decode(lud06, 1000)\n      let data = bech32.fromWords(words)\n      lnurl = utf8Decoder.decode(data)\n    } else if (lud16) {\n      let [name, domain] = lud16.split('@')\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`\n    } else {\n      return null\n    }\n\n    let res = await _fetch(lnurl)\n    let body = await res.json()\n\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback\n    }\n  } catch (err) {\n    /*-*/\n  }\n\n  return null\n}\n\nexport function makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = ''\n}: {\n  profile: string\n  event: string | null\n  amount: number\n  comment: string\n  relays: string[]\n}): EventTemplate {\n  if (!amount) throw new Error('amount not given')\n  if (!profile) throw new Error('profile not given')\n\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1000),\n    content: comment,\n    tags: [\n      ['p', profile],\n      ['amount', amount.toString()],\n      ['relays', ...relays]\n    ]\n  }\n\n  if (event) {\n    zr.tags.push(['e', event])\n  }\n\n  return zr\n}\n\nexport function validateZapRequest(zapRequestString: string): string | null {\n  let zapRequest: Event\n\n  try {\n    zapRequest = JSON.parse(zapRequestString)\n  } catch (err) {\n    return 'Invalid zap request JSON.'\n  }\n\n  if (!validateEvent(zapRequest))\n    return 'Zap request is not a valid Nostr event.'\n  if (!verifySignature(zapRequest)) return 'Invalid signature on zap request.'\n\n  let p = zapRequest.tags.find(([t, v]) => t === 'p' && v)\n  if (!p) return \"Zap request doesn't have a 'p' tag.\"\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\"\n\n  let e = zapRequest.tags.find(([t, v]) => t === 'e' && v)\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\"\n\n  let relays = zapRequest.tags.find(([t, v]) => t === 'relays' && v)\n  if (!relays) return \"Zap request doesn't have a 'relays' tag.\"\n\n  return null\n}\n\nexport function makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}: {\n  zapRequest: string\n  preimage: string | null\n  bolt11: string\n  paidAt: Date\n}): EventTemplate {\n  let zr: Event = JSON.parse(zapRequest)\n  let tagsFromZapRequest = zr.tags.filter(\n    ([t]) => t === 'e' || t === 'p' || t === 'a'\n  )\n\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1000),\n    content: '',\n    tags: [\n      ...tagsFromZapRequest,\n      ['bolt11', bolt11],\n      ['description', zapRequest]\n    ]\n  }\n\n  if (preimage) {\n    zap.tags.push(['preimage', preimage])\n  }\n\n  return zap\n}\n"],
  "mappings": "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",
  "names": ["secp256k1", "Kind", "id", "listeners", "type", "filters", "opts", "secp256k1", "import_utils", "secp256k1", "import_base", "secp256k1", "secp256k1", "secp256k1", "import_sha256", "tag", "useFetchImplementation", "_fetch", "useFetchImplementation", "import_base", "_fetch", "useFetchImplementation", "secp256k1", "import_sha256"]
}
